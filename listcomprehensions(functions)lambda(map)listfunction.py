# -*- coding: utf-8 -*-
"""listComprehensions(Functions)lambda(Map)Listfunction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11AZlcBSrvWUEXzzuhfnDDj_dy9_juvzt
"""

# Example 1: Iterating through a string Using for Loop
h_letters = []

for letter in 'human':
    h_letters.append(letter)

print(h_letters)

# Example 2: Iterating through a string Using List Comprehension
h_letters = [ letter for letter in 'human' ]
print( h_letters)

# Syntax of List Comprehension
# [expression for item in list]
# If you noticed, human is a string, not a list. This is the power of list comprehension. 
# It can identify when it receives a string or a tuple and work on it like a list.

h_letters = []
thistuple = ("apple", "banana", "cherry")
for letter in thistuple:
    h_letters.append(letter)

print(h_letters)

thistuple = ("apple", "banana", "cherry")
h_letters = [ letter for letter in thistuple ]
print( h_letters)

# lambda function
# A lambda function is a small anonymous function.

# A lambda function can take any number of arguments, but can only have one expression.
# lambda arguments : expression

# An argument is simply a value provided to a function when you call it: x = foo( 3 ) # 3 is the argument for foo 
# y = bar( 4, "str" ) # 4 and "str" are the two arguments for bar.
# A lambda function that adds 10 to the number passed in as an argument, and print the result:
x = lambda a : a + 10
print(x(5))

a=int(input())
b=a+10
print(b)

def checkingAbove(num):
  
  num1=num+10
  return num1

checkingAbove(5)

# lambda, any number of argument check
x = lambda a,b : a + b+10
print(x(5,0))

def argumentNo2LambdaCheck(a,b):
  c=a+b+10
  return c

argumentNo2LambdaCheck(5,0)

# Why Use Lambda Functions?
# The power of lambda is better shown when you use them as an anonymous function inside another function.

# Say you have a function definition that takes one argument, and that argument will be multiplied with an unknown number:

def myfunc(n):
  return lambda a : a * n

# Use that function definition to make a function that always doubles the number you send in:

myfunc(2)

def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)

print(mydoubler(11))

def doublerTriplerETC(num1,num2):
  num3=num1*num2
  return num3

doublerTriplerETC(11,2)
doublerTriplerETC(11,3)

print(doublerTriplerETC(11,2))
print(doublerTriplerETC(11,3))

# Or, use the same function definition to make both functions, in the same program:
def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)
mytripler = myfunc(3)

print(mydoubler(11))
print(mytripler(11))

# List comprehensions aren’t the only way to work on lists. 
# Various built-in functions and lambda functions can create and modify lists in less lines of code.

# Example 3: Using Lambda functions inside List
letters = list(map(lambda x: x, 'human'))
print(letters)

# map function
def addition(n): 
    return n + n 
  
# We double all numbers using map() 
numbers = (1, 2, 3, 4) 
result = map(addition, numbers) 
print(list(result))

def multiplication(n): 
    return n * n 
  
# We double all numbers using map() 
numbers = (1, 2, 3, 4) 
result = map(multiplication, numbers) 
print(list(result))

# Double all numbers using map and lambda 
  
numbers = (1, 2, 3, 4) 
result = map(lambda x: x + x, numbers) 
print(list(result))

numbers = (1, 2, 3, 4) 
result = map(lambda x: x * x, numbers) 
print(list(result))

# Add two lists using map and lambda 
  
numbers1 = [1, 2, 3] 
numbers2 = [4, 5, 6] 
  
result = map(lambda x, y: x + y, numbers1, numbers2) 
print(list(result))

# Add two lists using map and lambda 
  
numbers1 = [1, 2, 3] 
numbers2 = [4, 5, 6] 
num1=(7,8,9)
num2=(10,11,12)
  
result = map(lambda x, y: x + y, numbers1, numbers2) 
resultAnother=map(lambda x, y: x + y, num1, num2) 
print(list(result)) 
# print(list(resultAnother))
print(set(resultAnother))
# print(list(resultAnother)) :resultAnother used before and couldn't reuse

# Python map() function
# map() function returns a map object(which is an iterator) of the results 
# after applying the given function to each item of a given iterable (list, tuple etc.)
# map(fun, iter)
# fun : It is a function to which map passes each element of given iterable.
# iter : It is a iterable which is to be mapped.

# NOTE : You can pass one or more iterable to the map() function.
# Returns a list of the results after applying the given function  
# to each item of a given iterable (list, tuple etc.) 

# NOTE : The returned value from map() (map object) then can be passed to functions like list() (to create a list), 
# set() (to create a set) .

numbers1 = [1, 2, 3] 
numbers2 = [4, 5, 6] 
for i in numbers1:
  for j in numbers2:
    print(i+j)

numbers1 = [1, 2, 3] 
numbers2 = [4, 5, 6] 
result = lambda x, y: x + y, numbers1, numbers2
print(result)

resultUsingMap=map(lambda x, y: x + y, numbers1, numbers2)
print(list(resultUsingMap))

def additionList(a,b):
  c=a+b
  return c

numbers1 = [1, 2, 3] 
numbers2 = [4, 5, 6] 
additionList(numbers1,numbers2)

numbers1 = [1, 2, 3] 
numbers2 = [4, 5] 
result = lambda x, y: x + y, numbers1, numbers2
print(result)
resultUsingMap=map(lambda x, y: x + y, numbers1, numbers2)
print(list(resultUsingMap))

def additionList(a,b):
  c=a+b
  return c

numbers1 = [1, 2, 3] 
numbers2 = [4, 5] 
additionList(numbers1,numbers2)

# List of strings 
l = ['sat', 'bat', 'cat', 'mat'] 
  
# map() can listify the list of strings individually 
test = list(map(list, l)) 
print(test)

l = ['sat', 'bat', 'cat', 'mat'] 
for i in l:
  print(i)

l = ['sat', 'bat', 'cat', 'mat'] 
list(l)
# map(list(l)) : map() must have at least two arguments.
list(map(list, l))

# Python list()
# The list() constructor returns a list in Python.
# The syntax of list() is:

# list([iterable])

# empty list
print(list())

# vowel string
vowel_string = 'aeiou'
print(list(vowel_string))

# vowel tuple
vowel_tuple = ('a', 'e', 'i', 'o', 'u')
print(list(vowel_tuple))

# vowel list
vowel_list = ['a', 'e', 'i', 'o', 'u']
print(list(vowel_list))

# vowel set
vowel_set = {'a', 'e', 'i', 'o', 'u'}
print(list(vowel_set))

# vowel dictionary
vowel_dictionary = {'a': 1, 'e': 2, 'i': 3, 'o':4, 'u':5}
print(list(vowel_dictionary))

# Example 3: Create a list from an iterator object
# objects of this class are iterators
class PowTwo:
    def __init__(self, max):
        self.max = max
    
    def __iter__(self):
        self.num = 0
        return self
        
    def __next__(self):
        if(self.num >= self.max):
            raise StopIteration
        result = 2 ** self.num
        self.num += 1
        return result

pow_two = PowTwo(5)
pow_two_iter = iter(pow_two)

print(list(pow_two_iter))

# Conditionals in List Comprehension
# List comprehensions can utilize conditional statement to modify existing list (or other tuples). 
# We will create list that uses mathematical operators, integers, and range().

# Example 4: Using if with List Comprehension
number_list = [ x for x in range(20) if x % 2 == 0]
print(number_list)

number_list = [ x for x in range(20) if x % 2 != 0]
print(number_list)

number_list = [ x for x in range(6,20) if x % 2 != 0]
print(number_list)

for i in range(5):
  print(i)

# Example 5: Nested IF with List Comprehension
num_list = [y for y in range(100) if y % 2 == 0 if y % 5 == 0]
print(num_list)

obj = ["Even" if i%2==0 else "Odd" for i in range(10)]
print(obj)

for i in range(10):
  if i%2==0:
    print('Even')
  else:
    print("Odd")

# BUT how am I gonna pick it up in a list, that's why list comprehensions

# Example 7: Transpose of Matrix using Nested Loops
transposed = []
matrix = [[1, 2, 3, 4], [4, 5, 6, 8]]

for i in range(len(matrix[0])):
    transposed_row = []

    for row in matrix:
        transposed_row.append(row[i])
    transposed.append(transposed_row)

print(transposed)

# Example 8: Transpose of a Matrix using List Comprehension
matrix = [[1, 2], [3,4], [5,6], [7,8]]
transpose = [[row[i] for row in matrix] for i in range(2)]
print (transpose)

# Key Points to Remember
# List comprehension is an elegant way to define and create lists based on existing lists.
# List comprehension is generally more compact and faster than normal functions and loops for creating list.
# However, we should avoid writing very long list comprehensions in one line to ensure that code is user-friendly.
# Remember, every list comprehension can be rewritten in for loop, but every for loop can’t be rewritten in the form of list comprehension.